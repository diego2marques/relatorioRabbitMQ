{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"O que \u00e9 o RabbitMQ? O RabbitMQ \u00e9 um software de mensageria open-source amplamente utilizado para enviar e receber mensagens entre sistemas distribu\u00eddos. Ele implementa o protocolo AMQP (Advanced Message Queuing Protocol) e \u00e9 conhecido por sua confiabilidade, escalabilidade e flexibilidade. Principais caracter\u00edsticas Filas (Queues) : O RabbitMQ armazena as mensagens em filas, que podem ser consumidas por um ou mais consumidores. As filas garantem que as mensagens sejam entregues na ordem em que foram enviadas. Produtores (Producers) : Os produtores s\u00e3o respons\u00e1veis por enviar mensagens para as filas. Eles publicam mensagens para uma troca (Exchange), que, por sua vez, roteia as mensagens para as filas apropriadas. Consumidores (Consumers) : Os consumidores s\u00e3o respons\u00e1veis por receber as mensagens das filas e process\u00e1-las. Um consumidor pode ser qualquer aplica\u00e7\u00e3o ou servi\u00e7o que esteja conectado ao RabbitMQ. Trocas (Exchanges) : As trocas recebem mensagens dos produtores e determinam para qual fila ou filas essas mensagens devem ser roteadas. Existem diferentes tipos de trocas, como direct, fanout, topic e headers, cada uma com regras espec\u00edficas de roteamento. Bindings : Um binding \u00e9 uma conex\u00e3o entre uma troca e uma fila que define como as mensagens devem ser roteadas. As regras de binding determinam se uma mensagem deve ser entregue a uma fila espec\u00edfica. Mensagens : As mensagens em RabbitMQ podem conter qualquer tipo de dado, como texto, JSON, XML, etc. Elas s\u00e3o enviadas pelo produtor e processadas pelo consumidor. Usos comuns Desacoplamento de servi\u00e7os interconectados Voc\u00ea tem um servi\u00e7o backend que precisa enviar notifica\u00e7\u00f5es para os usu\u00e1rios finais. Existem dois canais de notifica\u00e7\u00e3o: e-mails e notifica\u00e7\u00f5es push para o aplicativo m\u00f3vel. O backend publica a notifica\u00e7\u00e3o em duas filas, uma para cada canal. Programas que gerenciam e-mails e notifica\u00e7\u00f5es push se inscrevem na fila de seu interesse e processam as notifica\u00e7\u00f5es assim que elas chegam. Chamada de Procedimento Remoto (RPC) Voc\u00ea \u00e9 propriet\u00e1rio de uma casa de shows. Os ingressos para os espet\u00e1culos s\u00e3o vendidos em v\u00e1rios sites e quiosques f\u00edsicos. Os pedidos de todos os canais devem passar por um processo complexo para determinar se um cliente realmente obter\u00e1 seus ingressos, dependendo da disponibilidade. O site ou quiosque espera receber uma resposta para o pedido no menor tempo poss\u00edvel. Os pedidos s\u00e3o publicados em uma fila no RabbitMQ com um ID de correla\u00e7\u00e3o. O chamador que enviou o pedido, ent\u00e3o, se inscreve em outra fila e aguarda uma resposta com o mesmo ID de correla\u00e7\u00e3o. Para alcan\u00e7ar baixa lat\u00eancia, uma fila cl\u00e1ssica \u00e9 adequada aqui, mas isso vem com o custo de menor seguran\u00e7a \u2014 o chamador ainda pode tentar novamente. Se o pedido n\u00e3o puder ser perdido, voc\u00ea pode preferir usar uma combina\u00e7\u00e3o de confirma\u00e7\u00f5es e filas de qu\u00f3rum para garantir que uma mensagem esteja segura uma vez confirmada. Essa topologia permite que o processamento de pedidos seja serializado para atend\u00ea-los em ordem de chegada. Isso evita a necessidade de transa\u00e7\u00f5es. Streaming Voc\u00ea administra uma plataforma de v\u00eddeos. Quando um usu\u00e1rio faz o upload de um novo v\u00eddeo, h\u00e1 v\u00e1rias tarefas a serem conclu\u00eddas ap\u00f3s o v\u00eddeo ser armazenado com seguran\u00e7a: realizar uma an\u00e1lise p\u00f3s-upload, transcodificar c\u00f3pias de qualidade inferior do v\u00eddeo, notificar outros usu\u00e1rios inscritos nas cria\u00e7\u00f5es do autor, e assim por diante. O servi\u00e7o de upload adiciona eventos de \"Novo v\u00eddeo\" a um stream do RabbitMQ. V\u00e1rias aplica\u00e7\u00f5es backend podem se inscrever nesse stream e ler novos eventos independentemente umas das outras. Os usu\u00e1rios devem ser notificados imediatamente, mas a an\u00e1lise p\u00f3s-upload pode esperar e ser executada uma vez por dia. IoT Voc\u00ea oferece servi\u00e7os de entrega de pacotes em toda a gal\u00e1xia. Voc\u00ea possui um enxame de drones espaciais que precisam relatar seu status regularmente para um servidor hospedado no exoplaneta Kepler-438 b. Infelizmente, a conectividade da rede n\u00e3o \u00e9 muito boa... Cada drone espacial executa um n\u00f3 RabbitMQ local independente que armazena temporariamente seus relat\u00f3rios at\u00e9 que uma conex\u00e3o com o RabbitMQ upstream seja poss\u00edvel. Quando os planetas est\u00e3o alinhados, o RabbitMQ do drone envia todos os relat\u00f3rios para o RabbitMQ upstream.","title":"Home"},{"location":"#o-que-e-o-rabbitmq","text":"O RabbitMQ \u00e9 um software de mensageria open-source amplamente utilizado para enviar e receber mensagens entre sistemas distribu\u00eddos. Ele implementa o protocolo AMQP (Advanced Message Queuing Protocol) e \u00e9 conhecido por sua confiabilidade, escalabilidade e flexibilidade.","title":"O que \u00e9 o RabbitMQ?"},{"location":"#principais-caracteristicas","text":"Filas (Queues) : O RabbitMQ armazena as mensagens em filas, que podem ser consumidas por um ou mais consumidores. As filas garantem que as mensagens sejam entregues na ordem em que foram enviadas. Produtores (Producers) : Os produtores s\u00e3o respons\u00e1veis por enviar mensagens para as filas. Eles publicam mensagens para uma troca (Exchange), que, por sua vez, roteia as mensagens para as filas apropriadas. Consumidores (Consumers) : Os consumidores s\u00e3o respons\u00e1veis por receber as mensagens das filas e process\u00e1-las. Um consumidor pode ser qualquer aplica\u00e7\u00e3o ou servi\u00e7o que esteja conectado ao RabbitMQ. Trocas (Exchanges) : As trocas recebem mensagens dos produtores e determinam para qual fila ou filas essas mensagens devem ser roteadas. Existem diferentes tipos de trocas, como direct, fanout, topic e headers, cada uma com regras espec\u00edficas de roteamento. Bindings : Um binding \u00e9 uma conex\u00e3o entre uma troca e uma fila que define como as mensagens devem ser roteadas. As regras de binding determinam se uma mensagem deve ser entregue a uma fila espec\u00edfica. Mensagens : As mensagens em RabbitMQ podem conter qualquer tipo de dado, como texto, JSON, XML, etc. Elas s\u00e3o enviadas pelo produtor e processadas pelo consumidor.","title":"Principais caracter\u00edsticas"},{"location":"#usos-comuns","text":"Desacoplamento de servi\u00e7os interconectados Voc\u00ea tem um servi\u00e7o backend que precisa enviar notifica\u00e7\u00f5es para os usu\u00e1rios finais. Existem dois canais de notifica\u00e7\u00e3o: e-mails e notifica\u00e7\u00f5es push para o aplicativo m\u00f3vel. O backend publica a notifica\u00e7\u00e3o em duas filas, uma para cada canal. Programas que gerenciam e-mails e notifica\u00e7\u00f5es push se inscrevem na fila de seu interesse e processam as notifica\u00e7\u00f5es assim que elas chegam. Chamada de Procedimento Remoto (RPC) Voc\u00ea \u00e9 propriet\u00e1rio de uma casa de shows. Os ingressos para os espet\u00e1culos s\u00e3o vendidos em v\u00e1rios sites e quiosques f\u00edsicos. Os pedidos de todos os canais devem passar por um processo complexo para determinar se um cliente realmente obter\u00e1 seus ingressos, dependendo da disponibilidade. O site ou quiosque espera receber uma resposta para o pedido no menor tempo poss\u00edvel. Os pedidos s\u00e3o publicados em uma fila no RabbitMQ com um ID de correla\u00e7\u00e3o. O chamador que enviou o pedido, ent\u00e3o, se inscreve em outra fila e aguarda uma resposta com o mesmo ID de correla\u00e7\u00e3o. Para alcan\u00e7ar baixa lat\u00eancia, uma fila cl\u00e1ssica \u00e9 adequada aqui, mas isso vem com o custo de menor seguran\u00e7a \u2014 o chamador ainda pode tentar novamente. Se o pedido n\u00e3o puder ser perdido, voc\u00ea pode preferir usar uma combina\u00e7\u00e3o de confirma\u00e7\u00f5es e filas de qu\u00f3rum para garantir que uma mensagem esteja segura uma vez confirmada. Essa topologia permite que o processamento de pedidos seja serializado para atend\u00ea-los em ordem de chegada. Isso evita a necessidade de transa\u00e7\u00f5es. Streaming Voc\u00ea administra uma plataforma de v\u00eddeos. Quando um usu\u00e1rio faz o upload de um novo v\u00eddeo, h\u00e1 v\u00e1rias tarefas a serem conclu\u00eddas ap\u00f3s o v\u00eddeo ser armazenado com seguran\u00e7a: realizar uma an\u00e1lise p\u00f3s-upload, transcodificar c\u00f3pias de qualidade inferior do v\u00eddeo, notificar outros usu\u00e1rios inscritos nas cria\u00e7\u00f5es do autor, e assim por diante. O servi\u00e7o de upload adiciona eventos de \"Novo v\u00eddeo\" a um stream do RabbitMQ. V\u00e1rias aplica\u00e7\u00f5es backend podem se inscrever nesse stream e ler novos eventos independentemente umas das outras. Os usu\u00e1rios devem ser notificados imediatamente, mas a an\u00e1lise p\u00f3s-upload pode esperar e ser executada uma vez por dia. IoT Voc\u00ea oferece servi\u00e7os de entrega de pacotes em toda a gal\u00e1xia. Voc\u00ea possui um enxame de drones espaciais que precisam relatar seu status regularmente para um servidor hospedado no exoplaneta Kepler-438 b. Infelizmente, a conectividade da rede n\u00e3o \u00e9 muito boa... Cada drone espacial executa um n\u00f3 RabbitMQ local independente que armazena temporariamente seus relat\u00f3rios at\u00e9 que uma conex\u00e3o com o RabbitMQ upstream seja poss\u00edvel. Quando os planetas est\u00e3o alinhados, o RabbitMQ do drone envia todos os relat\u00f3rios para o RabbitMQ upstream.","title":"Usos comuns"},{"location":"gettingStarted/","text":"Primeiros passos Vamos cubrir os b\u00e1sicos do RabbitMQ neste tutorial. Para come\u00e7armos precisamos instalar o RabbitMQ server, por favor siga o guia de instala\u00e7\u00e3o . Com o RabbitMQ server instalado, iremos seguir com o tutorial em Python , lembrando que o RabbitMQ pode ser usado com uma gama de diferentes tecnologias. E para isso teremos que instalar o pacote Pika 1.0.0 do python com o seguinte comando: python -m pip install pika --upgrade Gostaria de deixar claro tamb\u00e9m que neste tutorial iremos apenas tratar das filas tradicionais. Hello World! Nesta parte do tutorial, vamos escrever dois pequenos programas em Python: um produtor (remetente) que envia uma \u00fanica mensagem e um consumidor (receptor) que recebe mensagens e as imprime. \u00c9 o \"Hello World\" da mensageria. Enviando Nosso primeiro programa ser\u00e1 o send.py o qual ir\u00e1 mandar uma mensagem para nossa fila, para isso a primeira coisa que precisamos fazer \u00e9 abrir uma conex\u00e3o com o RAbbitMQ server: #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() Com isso estamos conectados, por\u00e9m temos que verificar que a fila j\u00e1 existe logo: channel.queue_declare(queue='hello') Agora sim estamos prontos para mandar uma mensagem, que ter\u00e1 uma string Hello World . channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print(\" [x] Sent 'Hello World!'\") Agora que j\u00e1 mandamos a mensagem, n\u00e3o podemos nos esquecer de fechar a conex\u00e3o connection.close() Recebendo Agora vamos consumir essa mensagem, melhor dizendo receber esta mensagem atrav\u00e9s do arquivo receive.py , o qual iremos seguir passos parecidos primeiro abrindo a conex\u00e3o com o server e verificando se a fila existe: #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() channel.queue_declare(queue='hello') Para receber mensagens pode ser um pouco mais complicado, a final precisamos de uma fun\u00e7\u00e3o de callback para que ativemos nosso consumidor assim que uma mensagem chegar: def callback(ch, method, properties, body): print(f\" [x] Received {body}\") Agora precisamos avisar o RabbitMQ que essa fun\u00e7\u00e3o callback est\u00e1 escutando a nossa fila: channel.basic_consume(queue='hello', auto_ack=True, on_message_callback=callback) E por \u00faltimo criamos um loop para que nosso consumidor fique esperando uma mensagem at\u00e9 que a aplica\u00e7\u00e3o seja interrompida: print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': try: main() except KeyboardInterrupt: print('Interrupted') try: sys.exit(0) except SystemExit: os._exit(0) Juntando tudo Primeiro vamos verificar os dois arquivos constru\u00eddos, o send.py deve estar assim: #!/usr/bin/env python import pika connection = pika.BlockingConnection( pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print(\" [x] Sent 'Hello World!'\") connection.close() E o receive.py : #!/usr/bin/env python import pika, sys, os def main(): connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') def callback(ch, method, properties, body): print(f\" [x] Received {body}\") channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': try: main() except KeyboardInterrupt: print('Interrupted') try: sys.exit(0) except SystemExit: os._exit(0) Agora que est\u00e1 tudo certo vamos testar nosso programa em um terminal. Primeiro vamos rodar nosso consumidor: python receive.py # => [*] Waiting for messages. To exit press CTRL+C Em seguida vamos rodar nosso produtor que ir\u00e1 enviar a mensagem: python send.py # => [x] Sent 'Hello World!' Se tudo saiu como o esperado, o output deve ser assim: # => [*] Waiting for messages. To exit press CTRL+C # => [x] Received 'Hello World!' Bom este foi o tutorial inicial, espero que posssa ter aprendido um pouco sobre esta ferramente e sobre mensagerias. Gostaria de deixar claro que a ferramente possui muito mais do que isso, e voc\u00ea pode acessar a documenta\u00e7\u00e3o completa na documenta\u00e7\u00e3o oficial","title":"Primeiros passos"},{"location":"gettingStarted/#primeiros-passos","text":"Vamos cubrir os b\u00e1sicos do RabbitMQ neste tutorial. Para come\u00e7armos precisamos instalar o RabbitMQ server, por favor siga o guia de instala\u00e7\u00e3o . Com o RabbitMQ server instalado, iremos seguir com o tutorial em Python , lembrando que o RabbitMQ pode ser usado com uma gama de diferentes tecnologias. E para isso teremos que instalar o pacote Pika 1.0.0 do python com o seguinte comando: python -m pip install pika --upgrade Gostaria de deixar claro tamb\u00e9m que neste tutorial iremos apenas tratar das filas tradicionais.","title":"Primeiros passos"},{"location":"gettingStarted/#hello-world","text":"Nesta parte do tutorial, vamos escrever dois pequenos programas em Python: um produtor (remetente) que envia uma \u00fanica mensagem e um consumidor (receptor) que recebe mensagens e as imprime. \u00c9 o \"Hello World\" da mensageria.","title":"Hello World!"},{"location":"gettingStarted/#enviando","text":"Nosso primeiro programa ser\u00e1 o send.py o qual ir\u00e1 mandar uma mensagem para nossa fila, para isso a primeira coisa que precisamos fazer \u00e9 abrir uma conex\u00e3o com o RAbbitMQ server: #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() Com isso estamos conectados, por\u00e9m temos que verificar que a fila j\u00e1 existe logo: channel.queue_declare(queue='hello') Agora sim estamos prontos para mandar uma mensagem, que ter\u00e1 uma string Hello World . channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print(\" [x] Sent 'Hello World!'\") Agora que j\u00e1 mandamos a mensagem, n\u00e3o podemos nos esquecer de fechar a conex\u00e3o connection.close()","title":"Enviando"},{"location":"gettingStarted/#recebendo","text":"Agora vamos consumir essa mensagem, melhor dizendo receber esta mensagem atrav\u00e9s do arquivo receive.py , o qual iremos seguir passos parecidos primeiro abrindo a conex\u00e3o com o server e verificando se a fila existe: #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() channel.queue_declare(queue='hello') Para receber mensagens pode ser um pouco mais complicado, a final precisamos de uma fun\u00e7\u00e3o de callback para que ativemos nosso consumidor assim que uma mensagem chegar: def callback(ch, method, properties, body): print(f\" [x] Received {body}\") Agora precisamos avisar o RabbitMQ que essa fun\u00e7\u00e3o callback est\u00e1 escutando a nossa fila: channel.basic_consume(queue='hello', auto_ack=True, on_message_callback=callback) E por \u00faltimo criamos um loop para que nosso consumidor fique esperando uma mensagem at\u00e9 que a aplica\u00e7\u00e3o seja interrompida: print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': try: main() except KeyboardInterrupt: print('Interrupted') try: sys.exit(0) except SystemExit: os._exit(0)","title":"Recebendo"},{"location":"gettingStarted/#juntando-tudo","text":"Primeiro vamos verificar os dois arquivos constru\u00eddos, o send.py deve estar assim: #!/usr/bin/env python import pika connection = pika.BlockingConnection( pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print(\" [x] Sent 'Hello World!'\") connection.close() E o receive.py : #!/usr/bin/env python import pika, sys, os def main(): connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') def callback(ch, method, properties, body): print(f\" [x] Received {body}\") channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': try: main() except KeyboardInterrupt: print('Interrupted') try: sys.exit(0) except SystemExit: os._exit(0) Agora que est\u00e1 tudo certo vamos testar nosso programa em um terminal. Primeiro vamos rodar nosso consumidor: python receive.py # => [*] Waiting for messages. To exit press CTRL+C Em seguida vamos rodar nosso produtor que ir\u00e1 enviar a mensagem: python send.py # => [x] Sent 'Hello World!' Se tudo saiu como o esperado, o output deve ser assim: # => [*] Waiting for messages. To exit press CTRL+C # => [x] Received 'Hello World!' Bom este foi o tutorial inicial, espero que posssa ter aprendido um pouco sobre esta ferramente e sobre mensagerias. Gostaria de deixar claro que a ferramente possui muito mais do que isso, e voc\u00ea pode acessar a documenta\u00e7\u00e3o completa na documenta\u00e7\u00e3o oficial","title":"Juntando tudo"},{"location":"installing/","text":"Como utilizar o RabbitMQ Server A \u00faltima release do RabbitMQ \u00e9 a 3.13.6 , para \u00e0 utilizarmos temos duas vertentes, ou utilizamos via a imagem da comunidade docker, ou podemos instalar em nossa m\u00e1quina. Utilizando imagem docker da comunidade Podemos seguir duas vertentes diferentes, utilizar a imagem Docker . da comunidade atrav\u00e9s do comando: # latest RabbitMQ 3.13 docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.13-management Instalando o RabbitMQ Ubuntu RabbitMQ j\u00e1 \u00e9 incluso nas vers\u00f5es padr\u00f5es do Ubuntu. Por\u00e9m, as vers\u00f5es inclusas est\u00e3o muitas vers\u00f5es atr\u00e1s da vers\u00e3o mais recente, e por isso podem n\u00e3o ter mais suporte. Logo irei trazer a forma mais comum de se instalar, utilizando Apt e Cloudsmith Mirrors. Primeiro instale as dependencias essenciais: sudo apt-get update -y sudo apt-get install curl gnupg -y Em seguida permita o apt HTTPS transport sudo apt-get install apt-transport-https Adicione as chaves dos reposit\u00f3rios: sudo apt-get install curl gnupg apt-transport-https -y ## Team RabbitMQ's main signing key curl -1sLf \"https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA\" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/com.rabbitmq.team.gpg > /dev/null ## Community mirror of Cloudsmith: modern Erlang repository curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-erlang.E495BB49CC4BBE5B.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg > /dev/null ## Community mirror of Cloudsmith: RabbitMQ repository curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-server.9F4587F226208342.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.9F4587F226208342.gpg > /dev/null Adicione a lista fonte do reposit\u00f3rio: sudo tee /etc/apt/sources.list.d/rabbitmq.list <<EOF ## Provides modern Erlang/OTP releases from a Cloudsmith mirror ## deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main # another mirror for redundancy deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main ## Provides RabbitMQ from a Cloudsmith mirror ## deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main # another mirror for redundancy deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main EOF E por \u00faltimo, instale os pacotes: sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \\ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\ erlang-runtime-tools erlang-snmp erlang-ssl \\ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing Windows Para Windows iremos utilizar o Chocolatey , e para instalar ser\u00e1 nescess\u00e1rio apenas rodar o comando a seguir: choco install rabbitmq","title":"Instala\u00e7\u00e3o"},{"location":"installing/#como-utilizar-o-rabbitmq-server","text":"A \u00faltima release do RabbitMQ \u00e9 a 3.13.6 , para \u00e0 utilizarmos temos duas vertentes, ou utilizamos via a imagem da comunidade docker, ou podemos instalar em nossa m\u00e1quina.","title":"Como utilizar o RabbitMQ Server"},{"location":"installing/#utilizando-imagem-docker-da-comunidade","text":"Podemos seguir duas vertentes diferentes, utilizar a imagem Docker . da comunidade atrav\u00e9s do comando: # latest RabbitMQ 3.13 docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.13-management","title":"Utilizando imagem docker da comunidade"},{"location":"installing/#instalando-o-rabbitmq","text":"","title":"Instalando o RabbitMQ"},{"location":"installing/#ubuntu","text":"RabbitMQ j\u00e1 \u00e9 incluso nas vers\u00f5es padr\u00f5es do Ubuntu. Por\u00e9m, as vers\u00f5es inclusas est\u00e3o muitas vers\u00f5es atr\u00e1s da vers\u00e3o mais recente, e por isso podem n\u00e3o ter mais suporte. Logo irei trazer a forma mais comum de se instalar, utilizando Apt e Cloudsmith Mirrors. Primeiro instale as dependencias essenciais: sudo apt-get update -y sudo apt-get install curl gnupg -y Em seguida permita o apt HTTPS transport sudo apt-get install apt-transport-https Adicione as chaves dos reposit\u00f3rios: sudo apt-get install curl gnupg apt-transport-https -y ## Team RabbitMQ's main signing key curl -1sLf \"https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA\" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/com.rabbitmq.team.gpg > /dev/null ## Community mirror of Cloudsmith: modern Erlang repository curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-erlang.E495BB49CC4BBE5B.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg > /dev/null ## Community mirror of Cloudsmith: RabbitMQ repository curl -1sLf https://github.com/rabbitmq/signing-keys/releases/download/3.0/cloudsmith.rabbitmq-server.9F4587F226208342.key | sudo gpg --dearmor | sudo tee /usr/share/keyrings/rabbitmq.9F4587F226208342.gpg > /dev/null Adicione a lista fonte do reposit\u00f3rio: sudo tee /etc/apt/sources.list.d/rabbitmq.list <<EOF ## Provides modern Erlang/OTP releases from a Cloudsmith mirror ## deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main # another mirror for redundancy deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-erlang/deb/ubuntu noble main ## Provides RabbitMQ from a Cloudsmith mirror ## deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main # another mirror for redundancy deb [arch=amd64 signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa2.rabbitmq.com/rabbitmq/rabbitmq-server/deb/ubuntu noble main EOF E por \u00faltimo, instale os pacotes: sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \\ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\ erlang-runtime-tools erlang-snmp erlang-ssl \\ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing","title":"Ubuntu"},{"location":"installing/#windows","text":"Para Windows iremos utilizar o Chocolatey , e para instalar ser\u00e1 nescess\u00e1rio apenas rodar o comando a seguir: choco install rabbitmq","title":"Windows"},{"location":"referencias/","text":"Referencias Docker Python Choco RabbitMQ Mkdocs Esta documenta\u00e7\u00e3o foi escrita por Diego Marques Andrade","title":"Refer\u00eancias"},{"location":"referencias/#referencias","text":"Docker Python Choco RabbitMQ Mkdocs Esta documenta\u00e7\u00e3o foi escrita por Diego Marques Andrade","title":"Referencias"}]}